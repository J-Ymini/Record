# DeepDive - 1 ~ 10장 필요 내용 정리

## 데이터 타입이 필요한 이유

- 값을 저장할때 확보해야하는 메모리 공간의 크기를 결정하기 위해서(변수의 타입에 따라 확보해야할 메모리 공간의 크기가 결정됨)

- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해서

- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해서

---

<br/>

## 동적 타이핑

- 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 값의 재할당으로 인해 변수의 타입은 동적으로 변할수 있는데, 이러한 특징을 동적 타이핑이라고 한다.

- 통적 타입 언어는 유연하지만, 신뢰성이 떨어지므로 동적 타입 언어의 변수 사용시 다음과 같은 주의사항이 필요
  1.  변수는 필요한 만큼, 최소한으로 유지
  2.  스코프는 최대한 좁게 만들어 사용
  3.  전역변수 기피
  4.  변수보다는 상수를 사용하여 값의 변경 억제(const 사용 권장)
  5.  네이밍 주의

---

<br/>

## 암묵적 타입 변환, 타입 강제 변환

- 개발자의 의도와 상관없이, 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되는 것을 **암묵적 타입 변환 or 타입 강제 변환**이라고 한다.

- 암묵적 타입 변환은, 기존 변수 값을 재할당하여 변경하는 것이 아닌, 값의 타입을 변환하여 새로운 타입의 값을 만든 후, 단 한번 사용하고 버린다.

---

<br/>

## 명시적 타입 변환(타입 캐스팅)

- 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** or **타입 캐스팅**이라고 한다.

---

<br/>

## NaN 비교

- 전역 객체 속성으로, 전역 스코프의 변수
- 초기값은 `Not-A-Number`로, `Number.NaN`과 동일
- 자기 자신과 일치하지 않는, 유일한 값
- `NaN`의 판별은 동등 연산자 or 일치 연산자가 아닌, `Number.isNan()` or `isNaN()`을 사용하여 정확한 판별 가능(추가로 `Object.is`를 사용해서도 가능)

```javascript
NaN === NaN; // false, 자신과 일치하지 않는 유일한 값

Object.is(NaN, NaN); // true

Number.isNaN(NaN); // true
```

---

<br/>

## switch문 fall through

- `switch`문을 사용할때 `switch`문을 탈출하지 않고 `switch`문이 끝날 때까지 모든 `case`문과 `default`문을 실행하는 현상(주로 `break`가 없을 경우 발생)

---

<br/>

## 옵셔널 체이닝

- ES11(ECMAScript2020)에서 도입된 옵셔널 체이닝 연산자는, 좌항의 피연산자가 `null` 또는 `undefined`일 경우 `undefined`를 반환하고 그렇지 않을 경우 우항의 프로퍼티 참조를 이어간다. (`&&` 연산자와 다르게, 좌항의 피연산자값을 반환하지 않음)

---

<br/>

## null 병합 연산자

- ES11(ECMAScript2020)에서 도입된 null 병합 연산자는 좌항의 피연산자는 `null` 또는 `undefined`일 경우 우항의 피연산자를 반환하며, 그렇지 않을 경우 좌항의 피연산자를 반환한다.
  (논리 연산자에서 값의 반환을 결정 짓는 truthy, falsy 값이 아닌, 오직 `null`과 `undefined`로 인해 결정지어진다.)
